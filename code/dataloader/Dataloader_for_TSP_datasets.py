# -*- coding: utf-8 -*-
"""最终大作业（总结TSP问题算法）.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1RbuBFjDMMJOdUdolHUidi7XJHm31H9LO

# 数据读取（要求能读取一整个文件夹的所有数据）
"""

# 自动切换网上平台或者本地路径
import platform
import os
import glob
import pandas as pd
import numpy as np
import re
import requests 
from bs4 import BeautifulSoup

check_sys = platform.system()
if check_sys == 'Linux':   # colab address
  # 从GoogLe Drive获取数据集，更换本地，需要data使用本地路径
  from google.colab import drive
  drive.mount('/content/drive/')
  # GoogLe Drive 路径
  data_folder = 'drive/MyDrive/现代优化计算方法/'
elif check_sys == 'Windows': # local address 
  # 本地路径
  data_folder = './data/'
else:
  raise EnvironmentError

# 文件路径拼接
tsp_data_path = os.path.join(data_folder,'*.tsp.gz')
atsp_data_path = os.path.join(data_folder,'*.atsp.gz')
tsp_data_path

# 获取目标文件夹下的测试样例
file_tsp = []
# 获取tsp数据
for filename in glob.glob(tsp_data_path):
    file_tsp.append(filename)
    
print(file_tsp)

file_atsp = []
# 获取atsp数据
for filename in glob.glob(atsp_data_path):
    file_atsp.append(filename)
    
print(file_atsp)

"""file_atsp

测试算法

df = pd.read_csv(file_tsp[2], header=None)
listtt = (df[0][6+1]+df[0][len(df)-2])
df1 = df[10:50]
string_data = listtt.strip().split(' ')
list_data =  [int(i) for i in string_data]

listtt = (df[0][6+1]+df[0][len(df)-2])
df1 = df[10:50]
# df1.split(' ')

### 数据集类型
index从0开始

#### 数据规约

```
规约部分具有以下条目：
NAME（必需）：数据集的名称。
TYPE（必需）：数据集的类型说明符。由枚举表示TspKind。
COMMENT（可选）：数据集的注释。
DIM（必需）：数据集的维度。
CAPACITY（如果TYPE是 则需要TspKind::Cvrp）：容量车辆路径问题 (CVRP) 中的卡车容量。
EDGE_WEIGHT_TYPE（必需）：指示如何计算边缘权重（或距离）。由枚举表示WeightKind。
EDGE_WEIGHT_FORMAT（如果EDGE_WEIGHT_TYPE是 则为必需WeightKind::Explicit）：指定文件中边权重的给出方式。由枚举表示WeightFormat。
EDGE_DATA_FORMAT（可选）：如果图形不完整，指定如何在文件中给出图形的边。由枚举表示EdgeFormat。
NODE_COORD_TYPE（如果EDGE_WEIGHT_TYPE不是则必需WeightKind::Explicit）：指定如何在文件中给出每个节点的坐标。由枚举表示CoordKind。
DISPLAY_DATA_TYPE（可选）：指定如何在文件中给出用于显示目的的每个节点的坐标。由枚举表示DisplayKind。

数据部分具有以下条目：
NODE_COORD_SECTION（如果NODE_COORD_TYPE不是则必需CoordKind::NoCoord）：节点坐标列表。
DEPOT_SECTION（与 相关TspKind::Cvrp）：可能的备用节点列表。
DEMAND_SECTION（与 相关TspKind::Cvrp）：所有节点的需求列表。每个条目都是一个元组(usize, usize)，其中第一个数字是节点的 id，第二个数字表示对该节点的需求。所有 depot 节点也必须包含在此部分中，并且它们的需求始终为0.
EDGE_DATA_SECTION: 边列表。
FIXED_EDGES_SECTION（可选）：必须包含在问题解决方案中的边列表。
DISPLAY_DATA_SECTION（如果DISPLAY_DATA_TYPE是 则必需DisplayKind::Disp2d）：用于显示目的的 2D 节点坐标列表。
TOUR_SECTION: 旅游合集。每个游览都是一个节点 ID 序列。
EDGE_WEIGHT_SECTIONEDGE_WEIGHT_FORMAT（如果是可选的WeightFormat::Function）：矩阵形式的节点坐标，如EDGE_WEIGHT_FORMAT.
```

[解释数据网站](https://docs.rs/tspf/0.3.0/tspf/struct.Tsp.html)

for i in range(4):
  print(i)
[i for i in range(5)][0:2]

_time_ = 0
@timmer
def p():
  for i in range(int(1e7)):
    i+3/2
p(),t,a
"""

# 定义一个修饰器函数用来统计函数的运行时间
# 参考我的csdn  https://blog.csdn.net/prinTao/article/details/121800857?spm=1001.2014.3001.5501
import time
# 尝试传时间参数出来
run_time_list=[]# 中途无法清空
def timmer(func):    #传入的参数是一个函数
    def deco(*args, **kwargs): #本应传入运行函数的各种参数
        #print('\n函数：{_funcname_}开始运行：'.format(_funcname_=func.__name__))
        start_time = time.time()#调用代运行的函数，并将各种原本的参数传入
        res = func(*args, **kwargs)
        end_time = time.time()
        run_time_list.append(end_time - start_time)
        print('函数:{_funcname_}运行了 {_time_}秒'
              .format(_funcname_=func.__name__, _time_=(end_time - start_time)))
        return res#返回值为函数
    return deco



# 运行时间时间参数出来 保存在 run_time_list
init_run_time_list=[]# 中途无法清空 
def timmer_TSP_DATA_init(func):    #传入的参数是一个函数
  def deco(*args, **kwargs): #本应传入运行函数的各种参数
    # print('\n函数：{_funcname_}开始运行：'.format(_funcname_=func.__name__))
    start_time = time.time()#调用代运行的函数，并将各种原本的参数传入
    res = func(*args, **kwargs)
    end_time = time.time()
    init_run_time_list.append(end_time - start_time)
    # print('函数:{_funcname_}运行了 {_time_}秒'
    #       .format(_funcname_=func.__name__, _time_=(end_time - start_time)))
    return res#返回值为函数
  return deco

class TSP_DATA:
  '''用于读取数据、存放图的数据结构

  类内变量：
    必有：
      self.NAME         测试样例名称
      self.TYPE         测试样例类型  TSP ATSP
      self.DIMENSION.      维度
      self.EDGE_WEIGHT_TYPE   边权值计算方式 决定读取方式 
      self.matrix        矩阵形式数据
      self.table .       邻接表形式数据

    可能有：
      self.EDGE_WEIGHT_FORMAT
      self.EDGE_DATA_FORMAT
      self.NODE_COORD_TYPE required if EDGE_WEIGHT_TYPE is not WeightKind::Explicit
  
  类内方法：

  '''
  # 初始化，读取数据，并获取表头的数据规约
  #@timmer_TSP_DATA_init # 专属修饰器，获得此方法运行时间，每次清空需要重新载入此类
  def __init__(self, path, requireTable=True, requireMatrix=True, load_now =True,debug=False):
    """传入单个数据地址，读取并且加载数据的表头
    path:
      单个测试样例的数据地址
    requireTable:
      需要邻接表？
    requireMatrix：
      需要邻接矩阵？  
    debug:
      是否打印详细信息
    """
    self.debug = debug
    # 读取数据文件
    raw_data, name = self.read_any_file(path)
    # # 无论如何名字都是第0行
    # self.name = raw_data.split(':')[1]
    self.get_headline(raw_data)
    # 保证数据名称和文件名称相同
    #assert self.NAME == name
    # 保证是TSP问题的文件，同时防止某些测试样例在类型后面瞎加东西
    if 'ATSP' in self.TYPE :
      self.TYPE = 'ATSP'
    elif 'TSP' in self.TYPE :
      self.TYPE = 'TSP'
    # 有数据区块 长条list
    self.rawnum = self.get_data_list(raw_data)
    if self.debug:
        print("名称",self.NAME)
        print("原始数据：",self.rawnum)
        print("维数",self.DIMENSION)
    # 计算邻接矩阵 和 邻接表
    if load_now:
      self.cal_table_and_matrix(requireTable=requireTable, requireMatrix=requireMatrix)

    
  def ATSP2TSP_np(self):
    """
    # 使用numpy ATSP 转换 TSP 注意矩阵规模翻倍了
    # 为了使算法方便观察，没有使用节省内存和更快的写法，
    # 但减少中间变量和新建数组，会显著加快程序运行
    """
    self.TYPE = "TSP"
    self.DIMENSION = self.DIMENSION * 2

    matrix = np.array(self.matrix)
    # 需要四个矩阵
    # left up
    lu = np.ones_like(matrix)*(10000)
    # ringt up 
    ru = matrix.T
    # right down
    rd = np.ones_like(matrix)*(10000)
    # 拼接矩阵
    # 先竖着拼接
    left = np.concatenate((lu,matrix),axis=0)
    right = np.concatenate((ru,rd),axis=0)
    # 整体拼接
    self.matrix = np.concatenate((left, right),axis=1).tolist()
    # 如果有其他，需要更新状态#todo
    try:
      if hasattr(self,"table"):
        self.cal_table_and_matrix(requireMatrix=False)
    except:
      pass

    
  def get_matrix(self):
    """从外界获取矩阵的接口
    """
    try:
        return self.matrix
    except:
        self.cal_table_and_matrix(requireTable=False)
        return self.matrix
      
  def get_table(self):
    """从外界获取矩阵的接口
    """
    try:
        return self.table
    except:
        self.cal_table_and_matrix(requireMatrix=False)
        return self.table      
        
  def get_coorodinate_list(self):
    """从外界获取坐标表的接口
    """
    if self.EDGE_WEIGHT_TYPE == "EXPLICIT":
        # 需要检查有没有地理坐标这个参数
        pass
    try:
        return list(self.coorodinate_table)
    except:
        self.get_coorodinate_table_from_raw()
        return list(self.coorodinate_table)
  

  def cal_table_and_matrix(self,requireTable=True,requireMatrix=True):
    if self.EDGE_WEIGHT_TYPE == "EXPLICIT":
      if not requireTable:
        self.matrix = self.get_adjacency_matrix()
      else:
        self.matrix = self.get_adjacency_matrix()
        if self.debug:
          print("矩阵",self.matrix)
        self.table = self.matrix_2_table(self.matrix)

    else:
      # 获取 self.coorodinate_table 城市坐标表
      self.get_coorodinate_table_from_raw()
      # 按照需要生成 邻接矩阵 或 邻接表
      if requireTable and requireMatrix:
        # 两种方法，一种由 邻接表 转化
        self.table = self.coordinate_2_table()
        self.matrix = self.table_2_matrix(self.table)
      elif requireMatrix:
        # 一种由坐标直接到表
        self.matrix = self.coordinate_2_matrix()
      elif requireTable:
        self.table = self.coordinate_2_table()

  def get_data_list(self, data_all):
    """ 返回数字数据，被关键字和EOF包裹。不做其他处理
    EXPLICIT EDGE_WEIGHT_SECTION 
      DGE_WEIGHT_SECTION
      0  273    0 1272  999    0  744  809 1519    0 1138  866  140 1425

    EUC_2D  NODE_COORD_SECTION
      NODE_COORD_SECTION
      1 4.35841e+02 5.87522e+02
      2 6.02539e+02 8.01704e+02
      有丢失城市的情况，补无穷
    
    return：
      EXPLICIT 一长条int的list，空格隔开
      else 三列 n行 list（划掉）
      else 一长条int的list，空格隔开
    
    update:
      数据还有浮点数，得改一下
      可能有‘  699'这样的数据，不能用数字判别，应该用 非字母逻辑
      
    """
    end_line = len(data_all)-2 # 去掉EOF -1 从零开始 -1
    if self.debug:
        print(data_all)

    # 距离矩阵
    if self.EDGE_WEIGHT_TYPE == 'EXPLICIT':
      # 此时是n*1的
      beging_line = 0
      
      for i in range(10):
        if 'EDGE_WEIGHT_SECTION' in data_all[0][i]:
          # 下一位开始是数据
          beging_line = i+1
          break
        else:
          pass
          #raise Exception("EDGE_WEIGHT_SECTION 关键字未找到")
      if self.debug:
        print("发现数据开头标志位置",beging_line)

      string_data = data_all[0][beging_line]
      for h in range(beging_line+1,end_line+1):
        # 清洗掉其他标签，如可视化等
        if data_all[0][h][0].isalpha():
          # 如果这条数据是字母，那么中断循环。由于数字有空格，不能用数字判别
          break
        # todo 中间是不是要人为加空格
        string_data = string_data + " " + data_all[0][h]
      string_data_split = string_data.strip().split(' ')
      list_data =  [float(i) for i in string_data_split if bool(re.search(r'\d',i))]
      if self.debug:
        print(string_data_split)
        print(list_data)
        
    # 坐标
    else: 
      beging_line = 0
      # if not 'NODE_COORD_SECTION' in data_all[0]:
      #   raise Exception("NODE_COORD_SECTION 关键字未找到")
      for i in range(10):
        # 或者是：index = lines.index('NODE_COORD_SECTION\n') 但是慢一点
        beging_line = beging_line+1
        if 'NODE_COORD_SECTION' in data_all[0][i]:
          break
              
      # 第一条单独获取
      string_data = data_all[0][beging_line]
      # 获取其余数字
      for h in range(beging_line+1,end_line+1):
        # 清洗掉其他标签，如可视化等
        if data_all[0][h][0].isalpha():
          # 如果这条数据是字母，那么中断循环。由于数字有空格，不能用数字判别
          break
        # todo 中间是不是要人为加空格
        string_data = string_data + ' ' + data_all[0][h]

      if self.debug:
        print("发现数据开头标志位置",beging_line)
        print("数据")
        print(data_all[0][0])
      string_data_split = string_data.strip().split(' ')
      # 使用浮点数 1e2就不用手动转换了      
      #  list_data =  [float(i) for i in string_data_split if i.isdigit()]# 会导致漏掉小数
      list_data =  [float(i) for i in string_data_split if not i.isspace() and i.strip()]
      if self.debug:
        print(string_data_split)
        print(list_data)

    # 这里取了简便 #todo
    return list_data

  # 获取表头数据规约
  def get_headline(self, raw_data):
    '''
    实现方法：可以用 index = lines.index('NODE_COORD_SECTION\n')
    '''
    head_dict = {}
    head_index = 0
    # 获取字母表头(好像没啥用，但是逻辑更通畅了)
    for h in range(len(raw_data)):
      if not raw_data[0][h][0].isalpha():
        break
      else:
        head_index = head_index + 1
      
    # 最多只有10个类型的表头
    for i in range(head_index):
      if ':' not in raw_data[0][i]:
        break
      # 构建字典
      head_dict[raw_data[0][i].split(':')[0].strip()] = raw_data[0][i].split(':')[1].strip()
    
    # 从字典获取信息，去掉左右空格
    self.NAME = head_dict['NAME']
    self.TYPE = head_dict['TYPE']
    self.DIMENSION = int(head_dict['DIMENSION'])
    self.EDGE_WEIGHT_TYPE = head_dict['EDGE_WEIGHT_TYPE']
    if self.TYPE == "CVRP": 
      # 载货问题时，需要卡车容量
      self.CAPACITY = head_dict['CAPACITY']
    else:
      pass

    if self.EDGE_WEIGHT_TYPE == "EXPLICIT": 
      # 距离在raw code中指定的情况下，要给出邻接矩阵存放方式
      # 数据开头  EDGE_WEIGHT_SECTION
      # 比如 UPPER_DIAG_ROW 上三角矩阵
      self.EDGE_WEIGHT_FORMAT = head_dict['EDGE_WEIGHT_FORMAT']
    else:
      if 'NODE_COORD_TYPE' in head_dict.keys():
        self.NODE_COORD_TYPE = head_dict['NODE_COORD_TYPE']
      # 但实际很多都没有
      # 理论上要满足： NODE_COORD_TYPE (required if EDGE_WEIGHT_TYPE is not WeightKind::Explicit): specifies how the coordinate for each node is given in the file. Represented by the enum CoordKind.
      # 数据开头：  NODE_COORD_SECTION
      pass
    
  # 读取文件，不予处理
  def read_any_file(self,thispath):
    # 判断是否是数据集
    if not os.path.isfile(thispath):
      raise Exception('数据读取报错，地址非文件')
    # 读取文件 raw数据
    # 报错 ParserError: Error tokenizing data. C error: Expected 1 fields in line 3, saw 4
    # https://blog.csdn.net/qq_33267306/article/details/120284044
    df = pd.read_csv(thispath,header=None,error_bad_lines=False)
    # 文件名
    if check_sys == 'Linux':   # colab address
      name = thispath.split('/')[-1].split('.')[0]
    elif check_sys == 'Windows': # local address 
      name = thispath.split('\\')[-1].split('.')[0]
    else:
      raise EnvironmentError
    return df,name

  def get_coorodinate_table_from_raw(self):
    """根据提取出来的一维list，恢复坐标矩阵 self.coorodinate_table 
    仅用于以坐标矩阵储存的数据，既排除 EXPLICT

    self.coorodinate_table
      字典 城市序号：｛【x，y】｝
    """
    assert self.EDGE_WEIGHT_TYPE != "EXPLICIT" ,"只有在坐标矩阵储存的数据才可使用此方法"
    assert self.DIMENSION*3 == len(self.rawnum) ,"长度对不上，数据集缺少城市"
    self.coorodinate_table = {}
    for i in range(self.DIMENSION):
      #todo，这里假设所有城市升序排列，属于偷懒行为
      self.coorodinate_table[i+1] = self.rawnum[i+1:i+3]
    
    self.coorodinate_table 
  
  # 根据 EDGE_WEIGHT_TYPE 距离计算方式，返回距离
  def cal_a_distance_by_coordinate(self,a,b):
    '''
    按照 城市编号 a -> b ，给出两点之间的距离
    可能的距离定义式：https://docs.rs/tspf/0.3.0/tspf/enum.WeightKind.html
      Explicit   权重在数据文件中明确给出。直接读出来就是距离。
      Euc2d    二维欧几里得距离。
      Euc3d    三维欧几里得距离。
      Max2d    二维马氏距离。？？？？这是衡量矩阵的？？？？
      Max3d    三维马氏距离。
      Man2d    二维曼哈顿距离。
      Man3d    三维曼哈顿距离。
      Ceil2d    向上取整的二维欧几里得距离。
      Geo     地理距离。 既欧氏距离
      Att     问题的特殊距离函数att48和att532。
      Xray1    版本 1 晶体学问题的特殊距离函数。
      Xray2    版本 2 晶体学问题的特殊距离函数。
      Custom    用户定义的距离函数。
      Undefined  没有给出距离函数。
    '''
    this_x = self.coorodinate_table[a][0]
    this_y = self.coorodinate_table[a][1]
    next_x = self.coorodinate_table[b][0]
    next_y = self.coorodinate_table[b][1]

    if self.EDGE_WEIGHT_TYPE == "EUC_2D" or self.EDGE_WEIGHT_TYPE =="GEO":
      distance = (this_x - next_x)**2+\
            (this_y - next_y)**2

    elif self.EDGE_WEIGHT_TYPE == "EUC_3D":
      distance = abs((this_x - next_x)**3+\
              (this_y - next_y)**3)

    elif self.EDGE_WEIGHT_TYPE == "EXPLICIT":
      raise Exception("EXPLICIT距离必须由raw data的邻接矩阵给出")

    elif self.EDGE_WEIGHT_TYPE == "MAN_2D":
      distance = abs((this_x - next_x ) + \
              abs(this_y - next_y))

    elif self.EDGE_WEIGHT_TYPE == "MAN_3D":
      distance = abs((this_x - this_y)**3-\
              (next_x - next_y)**3)

    elif self.EDGE_WEIGHT_TYPE == "CEIL_2D":
      distance = int((this_x - next_x)**2+\
              (this_y - next_y)**2) + 1
    
    elif self.EDGE_WEIGHT_TYPE == "MAX_2D":
      distance = max(abs(this_y - next_y), abs(this_x - next_x))
    
    elif self.EDGE_WEIGHT_TYPE == "ATT":
      distance = round((this_x - next_x)**2+(this_y - next_y)**2)
    else: # 都不符合
      raise Exception("此类型距离未定义")
    return distance

  # 根据 TYPE 进行判断，返回邻接矩阵
  def get_adjacency_matrix(self):
    '''专用于TSP问题的原始数据转矩阵函数（由于ATSP距离不对称，优化不能用）
          
      当确认矩阵储存方式 EDGE_WEIGHT_TYPE 为 邻接矩阵 EXPLICIT 时
      self.EDGE_WEIGHT_FORMAT 保存矩阵储存格式
      self.rawnum 保存raw data中的所有数字
    矩阵存放形式
      Function    权重由WeightKind中所述的函数计算。
    FullMatrix   权重以完整矩阵形式给出。对应FULL_MATRIX于 TSPLIB 中的值。
    UpperRow    权重在上三角矩阵中按行给出，没有对角线条目。  对应UPPER_ROW于 TSPLIB 中的值。
    LowerRow    权重在下三角矩阵中给出，按行排列，没有对角线条目。 对应LOWE_ROW于 TSPLIB 中的值。
    UpperDiagRow  权重在上三角矩阵中给出，按行与对角线条目。  对应UPPER_DIAG_ROW于 TSPLIB 中的值。
    LowerDiagRow  权重在下三角矩阵中给出，按行与对角线条目。  对应LOWER_DIAG_ROW于 TSPLIB 中的值。
      UpperCol    权重在上三角矩阵中给出，没有对角线条目。  对应UPPER_COL于 TSPLIB 中的值。
      LowerCol    权重在下三角矩阵中给出，没有对角线条目。  对应LOWER_COL于 TSPLIB 中的值。
      UpperDiagCol  权重在上三角矩阵中给出，与对角线条目并列。  对应UPPER_DIAG_COL于 TSPLIB 中的值。
      LowerDiagCol  权重在下三角矩阵中给出，与对角线条目并列。  对应LOWER_DIAG_COL于 TSPLIB 中的值。
    Undefined    没有说明如何存储权重。
    '''
    # if self.TYPE == "TSP":
    matrix = []
    # 上三角，包含对角全0
    if self.EDGE_WEIGHT_FORMAT == "UPPER_DIAG_ROW":
      # 数据长度应该是：d + d-1 + d-2 +...+ 1 = (1+d)*d/2
      d = self.DIMENSION
      if not len(self.rawnum) == int((1+d)*d/2):
        raise Exception("获取的raw num数据量不对")
      for i in range(d):
        # 由于自己有0，第一行不填0，第二行补一个，第n行补n-1个
        row = [0 for j in range(i)]
        # left = sum 0 d d-1 \
        left = int( i*d-(0+i-1)*i/2 )
        right = int( (i+1)*d-(0+i)*(i+1)/2 )
        # right = sum d d-1 d-2 ... = i*d-(0+i-1)*i/2
        row = row + self.rawnum[left : right]
        matrix.append(row)
      # 上三角补全到完整矩阵
      m = np.array(matrix)
      matrix = (np.triu(m, k=1).T + np.triu(m, k=0)).tolist()

    # 下三角 包括对角线 LOWER_DIAG_ROW
    if self.EDGE_WEIGHT_FORMAT == "LOWER_DIAG_ROW":
      # 数据长度应该是：d + d-1 + d-2 +...+ 1 = (1+d)*d/2
      d = self.DIMENSION
      # 转化为上三角
      self.rawnum.reverse()
      if not len(self.rawnum) == int((1+d)*d/2):
        raise Exception("获取的raw num数据量不对")
      for i in range(d):
        # 由于自己有0，第n行不填0，第n-1行补一个，第1行补n-1个
        row = [0 for j in range(i)]
        # left = sum 0 d d-1 \
        left = int( i*d-(0+i-1)*i/2 )
        right = int( (i+1)*d-(0+i)*(i+1)/2 )
        # right = sum d d-1 d-2 ... = i*d-(0+i-1)*i/2
        row = row + self.rawnum[left : right]
        matrix.append(row)
      # 下三角补全到完整矩阵
      m = np.array(matrix)
      matrix = (np.tril(m, k=1).T + np.tril(m, k=0)).tolist()

    # 上三角，不包含对角全0
    elif self.EDGE_WEIGHT_FORMAT == "UPPER_ROW":
      """
      213 145  36
      94 217
      162
      """
      # 数据长度应该是：d + d-1 + d-2 +...+ 1 = (1+d)*d/2
      d = self.DIMENSION
      if not len(self.rawnum) == int((1+d)*d/2-d):
        raise Exception("获取的raw num数据量不对")
      for i in range(d):
        # 由于自己没0，第一行填1个0，第二行补2个，第n行补n+1个
        row = [0 for j in range(i+1)]
        # left = sum 0 d-1 d-2 
        left = int( d*i -(1+i)*i/2 )
        # right = sum d-1 d-2 d-3 ... = int(d*i -(1+i)i/2)
        # right = int( d*i -(1+i)*i/2 )
        right = int( d*(i+1) -(2+i)*(i+1)/2 )
        row = row + self.rawnum[left : right]
        matrix.append(row)
      # 上三角补全到完整矩阵
      m = np.array(matrix)
      matrix = (np.triu(m, k=1).T + np.triu(m, k=0)).tolist()
    
    # 下三角，不包含对角全0
    elif self.EDGE_WEIGHT_FORMAT == "LOWER_ROW":
      # 数据长度应该是：d + d-1 + d-2 +...+ 1 = (1+d)*d/2
      d = self.DIMENSION
      self.rawnum.reverse()
      if not len(self.rawnum) == int((1+d)*d/2-d):
        raise Exception("获取的raw num数据量不对")
      for i in range(d):
        # 由于自己有0，第一行填1个0，第二行补2个，第n行补n个
        row = [0 for j in range(i+1)]
        # left = sum 0 d-1 d-2 
        if i == 0:
          left = 0
        else:
          left = int( d*(i-1) -(i-1)*i/2 )
        # right = sum d-1 d-2 d-3 ... = int(d*i -(1+i)i/2)
        right = int( d*i -(1+i)*i/2 )
        row = row + self.rawnum[left : right]
        matrix.append(row)
      # 下三角补全到完整矩阵
      m = np.array(matrix)
      matrix = (np.tril(m, k=1).T + np.tril(m, k=0)).tolist()

    elif self.EDGE_WEIGHT_FORMAT == "FULL_MATRIX":
      # 数据长度应该是：d**2
      d = self.DIMENSION
      if not len(self.rawnum) == int(d**2):
        raise Exception("获取的raw num数据量不对")
      for i in range(d):
        row = self.rawnum[i:i+d]
        matrix.append(row)

    elif self.EDGE_WEIGHT_FORMAT == "UNDIFINED":
      d = self.DIMENSION
      # 进行辨识
      #  "FULL_MATRIX"
      if len(self.rawnum) == int(d**2):
        for i in range(d):
          row = self.rawnum[i:i+d]
          matrix.append(row)
      # 下三角，不包含对角全0
      elif len(self.rawnum) == int((1+d)*d/2-d):
        for i in range(d):
          # 由于自己有0，第一行填1个0，第二行补2个，第n行补n个
          row = [0 for j in range(i+1)]
          # left = sum 0 d-1 d-2 
          if i == 0:
            left = 0
          else:
            left = int( d*(i-1) -(i-1)*i/2 )
          # right = sum d-1 d-2 d-3 ... = int(d*i -(1+i)i/2)
          right = int( d*i -(1+i)*i/2 )
          row = row + self.rawnum[left : right]
          matrix.append(row)
        # 上三角补全到完整矩阵
        m = np.array(matrix)
        matrix = (np.triu(m, k=1).T + np.triu(m, k=0)).tolist()
      # 上下三角，不包含对角全0
      elif len(self.rawnum) == int((1+d)*d/2-d):
        if self.rawnum[2] == 0:
          # 下三角
          for i in range(d):
            # 由于自己有0，第一行填1个0，第二行补2个，第n行补n个
            row = [0 for j in range(i+1)]
            # left = sum 0 d-1 d-2 
            if i == 0:
              left = 0
            else:
              left = int( d*(i-1) -(i-1)*i/2 )
            # right = sum d-1 d-2 d-3 ... = int(d*i -(1+i)i/2)
            right = int( d*i -(1+i)*i/2 )
            row = row + self.rawnum[left : right]
            matrix.append(row)
          # 上三角补全到完整矩阵
          m = np.array(matrix)
          matrix = (np.tril(m, k=1).T + np.tril(m, k=0)).tolist()
        else:
          for i in range(d):
            # 由于自己有0，第一行不填0，第二行补一个，第n行补n-1个
            row = [0 for j in range(i)]
            # left = sum 0 d d-1 \
            left = int( i*d-(0+i-1)*i/2 )
            right = int( (i+1)*d-(0+i)*(i+1)/2 )
            # right = sum d d-1 d-2 ... = i*d-(0+i-1)*i/2
            row = row + self.rawnum[left : right]
            matrix.append(row)
          # 上三角补全到完整矩阵
          m = np.array(matrix)
          matrix = (np.triu(m, k=1).T + np.triu(m, k=0)).tolist()
      else:
        raise Exception("储存矩阵形式为定义，且未辨识成功，长度不符合已有类型")
    else:
      print(self.EDGE_WEIGHT_FORMAT)
      raise Exception("储存矩阵形式不支持")

    return matrix
  
  # 坐标表转换邻接表
  # 根据数据类型，返回数据的邻接表，有的算法需要这个
  def coordinate_2_table(self, optimize=True):
    """
    当数据为坐标地图：
      坐标表方式储存，每个x->y都需要计算。
      规定城市编号从一开始
    进一步：
      #todo
      优化计算，只用算一半
    retrun:
      字典好查询
      或者是表
    optimize:
      是否使用优化计算方法获取矩阵
    """
    whole_table = {}
    # ATSP 问题邻接矩阵不对称
    if optimize and self.TYPE != 'ATSP':
      for i in range(1,1+self.DIMENSION):
        for j in range(1,1+self.DIMENSION):
          if j >= i :
            whole_table[(i,j)] = self.cal_a_distance_by_coordinate(i,j)
      # 减小计算量（#todo能不能用矩阵对称算法？矩阵转置，然后相加）
      for i in range(1,1+self.DIMENSION):
        for j in range(1,1+self.DIMENSION):
          if j < i :
            whole_table[(i,j)] = whole_table[(j,i)]
    else:
      for i in range(1,1+self.DIMENSION):
        for j in range(1,1+self.DIMENSION):
          whole_table[(i,j)] = self.cal_a_distance_by_coordinate(i,j)

    return whole_table

  def coordinate_2_matrix(self, optimize=True):
    """
    当数据为坐标地图：
      坐标表方式储存，每个x->y都需要计算。
      规定城市编号从一开始
      第一行意为：从城市1到。。。
      注意索引是0开始
    进一步：
      #todo
      优化计算，只用算一半
      使用numpy，对角矩阵获取，转置，相加，即可
    """
    whole_matrix = []
    if optimize and self.TYPE != 'ATSP':
      for i in range(1,1+self.DIMENSION):
        thisRow = []
        for j in range(1,1+self.DIMENSION):
          if i<j: #上三角
            thisRow.append(self.cal_a_distance_by_coordinate(i,j))
          else:
            thisRow.append(0)
        whole_matrix.append(thisRow)
      # 上三角补全到完整矩阵
      m = np.array(whole_matrix)
      whole_matrix = (np.triu(m, k=1).T + np.triu(m, k=0)).tolist()
    else:
      for i in range(1,1+self.DIMENSION):
        thisRow = []
        for j in range(1,1+self.DIMENSION):
          thisRow.aooend(self.cal_a_distance_by_coordinate(i,j))
        whole_matrix.append(thisRow)

    return whole_matrix

  # 坐标表转换到矩阵
  def table_2_matrix(self,table):
    """
    table:
      字典类型，x-》y索引距离
    """
    whole_matrix = []
    for i in range(1,1+self.DIMENSION):
      thisRow = []
      for j in range(1,1+self.DIMENSION):
        thisRow.append(table[(i,j)])
      whole_matrix.append(thisRow)

    return whole_matrix

  # 矩阵转邻接表
  def matrix_2_table(self,matrix):
    """   
      矩阵储存， 需要提取表
      区分情况，是否对称等
    """
    whole_table = {}
    for i in range(1,1+self.DIMENSION):
      for j in range(1,1+self.DIMENSION):
        whole_table[(i,j)] = matrix[i-1][j-1]

    return whole_table
  
  # 检查数据合理性
  def check_if_reasonable(self):
    """
      检查表头信息识别是否有误
      检查基本逻辑信息
    """
    if self.TYPE == "ATSP":
      # ATSP只可能用矩阵来保存
      assert self.EDGE_WEIGHT_TYPE == "EXPLICIT"

    if self.TYPE == "TSP":
      # TSP产生的矩阵只可能是对称矩阵
      assert self.check_if_summetry(self.matrix),"邻接矩阵非对称"

    return True  

  def check_if_summetry(matrix):
    X = np.array(matrix)
    X = np.triu(X)
    X += X.T - np.diag(X.diagonal())
    # 保证所有元素相同
    return (X.T == X).all()
  
  def get_best_result_from_web(url = 'http://elib.zib.de/pub/mp-testdata/tsp/tsplib/stsp-sol.html'):
    resp = requests.get(url = url)
    html = resp.text
    soup = BeautifulSoup(html,"html.parser")
    best_res_dict={}
    try:
      title_url_Date=soup.find_all('li')
      #a=title_url_Date[0]
      
      for i in title_url_Date:
        txt_content = i.text
        # 有的数据解有两个。。。
        # ValueError: invalid literal for int() with base 10: '[468942,469935]'
        try:
            best_res_dict[txt_content.split(':')[0].strip()] = int(txt_content.split(':')[1].strip())
        except:
            print("网页抓到异常数据")
      print("当前最好的解",best_res_dict)
                    
    except:
    	print("未发现目标元素")

    return best_res_dict
# 这里出现了问题，考虑到删除掉之前加入的几个函数？


def TSP_load(path, requireTable=True, requireMatrix=True, load_now =True):
  """传入单个数据地址，读取并且加载数据的表头
  path:
    单个测试样例的数据地址
  requireTable:
    需要邻接表？
  requireMatrix：
    需要邻接矩阵？  
  """
  tsp = TSP_DATA(path,  requireTable=True, requireMatrix=True, load_now =True)
  return tsp




















"""a=[]
a.append([1,2])

## 验证数据、测试算法小模块

# 测试二维字典
tst_dict = {
    (2,4):3.1, (5,2):23.4
}
tst_dict = {
    (2,1):3.1, (1,2):23.4
}
# 会覆盖
tst_dict[(1,7)] = 0
tst_dict, tst_dict[(1,2)]

# 测试快速获取对角矩阵，优化计算速度
# https://blog.csdn.net/xiaoxiao_ziteng/article/details/114870770
a=[[1,2,3],[3,4,5],[5,6,7]]
m=np.array(a)
(np.triu(m, k=1).T + np.triu(m, k=0)).tolist()

# 验证数据加载的转换公式
d=5
for i in range(d):
  print((i*d-(0+i-1)*i/2)-1,((i+1)*d-(0+i)*(i+1)/2)-1)
  type(((i+1)*d-(0+i)*(i+1)/2))
  print([i for i in range(15)][int(i*d-(0+i-1)*i/2 -1) : int((i+1)*d-(0+i)*(i+1)/2 -1)])
"""



"""#### 例子

```
0	NAME: si535  
1	TYPE: TSP (M.~Hofmeister)  
2	维度 DIMENSION: 535
3	边权重计算方式 EDGE_WEIGHT_TYPE: EXPLICIT 这是什么距离
4	边权重形式 EDGE_WEIGHT_FORMAT: UPPER_DIAG_ROW 上三角 邻接矩阵法
5	展示形式 DISPLAY_DATA_TYPE: NO_DISPLAY
6	权重如下 EDGE_WEIGHT_SECTION
```

```
NAME : pr264
COMMENT : 264-city problem (Padberg/Rinaldi)
TYPE : TSP
DIMENSION : 264
EDGE_WEIGHT_TYPE : EUC_2D 邻接表法 
节点如下 NODE_COORD_SECTION
```
"""


"""报错：EUC_2D和EXPLICIT

### 最优结果读取
.opt.tour
```
NAME : bays29.opt.tour
COMMENT : Optimum solution of bays29
TYPE : TOUR
DIMENSION : 29
TOUR_SECTION
```
"""



"""报错

```
, sep=" ", skiprows=6, header=None
```

head_dict = {}
for i in range(10):
  if ':' not in df[0][i]:
    break
  head_dict[df[0][i].split(':')[0]] = df[0][i].split(':')[1]
head_dict
"""



"""data_tsp = [] # 【【名字，数据】，下一条，。。。。】
for tsp in file_tsp:
    # raw数据
    df = pd.read_csv(tsp, sep=" ", skiprows=6, header=None)
    # 文件名
    if check_sys == 'Linux':   # colab address
      name = tsp.split('/')[-1].split('.')[0]
    elif check_sys == 'Windows': # local address 
      name = tsp.split('\\')[-1].split('.')[0]
    else:
      raise EnvironmentError
    
    # 城市序号
    citys = np.array(df[0][0:len(df)-2])
    city_list = citys.tolist()
    # 城市坐标
    city_x = np.array(df[1][0:len(df)-2])
    city_y = np.array(df[2][0:len(df)-2])
    # 转换邻接矩阵 二维矩阵【【第一行】，【第2行】，。。。。】
    connection_matrix = []

# 网络性质（用于建立模型衡量数据性质）
1. 直径
2. 不均衡性
3. 平均路径

# 直观解释（为什么这个算法适合这类型的数据）
"""